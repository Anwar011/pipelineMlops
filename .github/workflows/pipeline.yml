name: MLOps Pipeline

on:
  push:
    branches:
      - main
    paths:
      - 'data/raw.dvc'
      - '.dvc/**'
      - 'data/raw/**'
  workflow_dispatch:  # Trigger manuel pour tests

jobs:
  train-and-deploy:
    runs-on: self-hosted  # Utiliser self-hosted runner
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Setup Python (if not available)
      shell: cmd
      run: |
        @echo off
        where python3 >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python3 --version
          goto :end
        )
        where python >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python --version
          goto :end
        )
        echo Python3 non trouvé, installation requise
        exit /b 1
        :end
    
    - name: Install dependencies
      shell: cmd
      run: |
        @echo off
        where python3 >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python3 -m pip install --upgrade pip --user
          python3 -m pip install -r requirements.txt --user
        ) else (
          python -m pip install --upgrade pip --user
          python -m pip install -r requirements.txt --user
        )
        set "PATH=%USERPROFILE%\.local\bin;%PATH%"
    
    - name: Install DVC (if not available)
      shell: cmd
      run: |
        @echo off
        where dvc >nul 2>&1
        if %ERRORLEVEL% NEQ 0 (
          where python3 >nul 2>&1
          if %ERRORLEVEL% EQU 0 (
            python3 -m pip install "dvc[s3]" --user
          ) else (
            python -m pip install "dvc[s3]" --user
          )
          set "PATH=%USERPROFILE%\.local\bin;%PATH%"
        )
    
    - name: Setup DVC
      shell: cmd
      run: |
        @echo off
        set "PATH=%USERPROFILE%\.local\bin;%PATH%"
        dvc remote modify storage --local url .dvc/storage 2>nul
        if %ERRORLEVEL% NEQ 0 (
          echo Remote config failed, continuons...
        )
        dvc pull 2>nul
        if %ERRORLEVEL% NEQ 0 (
          echo [INFO] Pas de donnees DVC disponibles dans le storage local
          echo [INFO] Tentative de copie automatique des donnees...
        )
        exit /b 0
    
    - name: Copy data if needed (self-hosted runner)
      shell: cmd
      run: |
        @echo off
        set "PATH=%USERPROFILE%\.local\bin;%PATH%"
        set "PYTHONPATH=."
        where python3 >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python3 scripts/copy_data_if_needed.py
        ) else (
          python scripts/copy_data_if_needed.py
        )
        if %ERRORLEVEL% NEQ 0 (
          echo [ATTENTION] Les donnees n'ont pas pu etre copiees automatiquement
          echo [INFO] Assurez-vous que les donnees sont disponibles dans data/raw/PlantVillage
        )
        exit /b 0
    
    - name: Check for data changes with DVC
      id: check_dvc
      shell: cmd
      env:
        GITHUB_EVENT_NAME: ${{ github.event_name }}
      run: |
        @echo off
        set "PATH=%USERPROFILE%\.local\bin;%PATH%"
        where python3 >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python3 scripts/check_dvc_changes.py
        ) else (
          python scripts/check_dvc_changes.py
        )
        exit /b 0
    
    - name: Prepare data
      if: steps.check_dvc.outputs.changed == 'true'
      shell: cmd
      run: |
        @echo off
        set "PYTHONPATH=."
        set "PATH=%USERPROFILE%\.local\bin;%PATH%"
        where python3 >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python3 scripts/prepare_data.py
        ) else (
          python scripts/prepare_data.py
        )
 
    - name: Verify MLflow is running (for training)
      if: steps.check_dvc.outputs.changed == 'true'
      shell: cmd
      run: |
        @echo off
        echo Vérification que MLflow est accessible...
        curl -f http://localhost:5000/health >nul 2>&1
        if %ERRORLEVEL% NEQ 0 (
          echo [ERREUR] MLflow n'est pas accessible sur http://localhost:5000
          echo Veuillez démarrer MLflow avec: cd docker ^&^& docker-compose up -d mlflow
          exit /b 1
        )
        echo [OK] MLflow est accessible
 
    - name: Train model
      if: steps.check_dvc.outputs.changed == 'true'
      shell: cmd
      run: |
        @echo off
        echo [INFO] Phase entrainement presente mais SKIP (test pipeline rapide)
        echo [INFO] Aucun entrainement lance, on conserve le dernier modele MLflow
        exit /b 0
 
    - name: Verify model in MLflow
      if: steps.check_dvc.outputs.changed == 'true'
      shell: cmd
      run: |
        @echo off
        set "PYTHONPATH=."
        set "PATH=%USERPROFILE%\.local\bin;%PATH%"
        where python3 >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python3 scripts/verify_mlflow.py
        ) else (
          python scripts/verify_mlflow.py
        )
    
    - name: Verify MLflow is running
      shell: cmd
      run: |
        @echo off
        echo Vérification que MLflow est accessible...
        curl -f http://localhost:5000/health >nul 2>&1
        if %ERRORLEVEL% NEQ 0 (
          echo [ERREUR] MLflow n'est pas accessible sur http://localhost:5000
          echo Veuillez démarrer MLflow avec: cd docker ^&^& docker-compose up -d mlflow
          exit /b 1
        )
        echo [OK] MLflow est accessible
    
    - name: Get latest model from MLflow
      shell: cmd
      run: |
        @echo off
        echo [INFO] Recuperation du modele depuis MLflow (modele deja entraine)
        set "PYTHONPATH=."
        set "PATH=%USERPROFILE%\.local\bin;%PATH%"
        where python3 >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python3 scripts/get_latest_model.py --tracking-uri http://localhost:5000 --experiment-name plant_disease_mvp --output-file models/best_model.pth
        ) else (
          python scripts/get_latest_model.py --tracking-uri http://localhost:5000 --experiment-name plant_disease_mvp --output-file models/best_model.pth
        )
    
    - name: Build Docker image
      shell: cmd
      run: |
        @echo off
        docker build -t plant-disease-api:${{ github.sha }} -f docker/Dockerfile .
        docker tag plant-disease-api:${{ github.sha }} plant-disease-api:latest
        echo [OK] Image Docker buildée: plant-disease-api:${{ github.sha }}
    
    - name: Load Docker image into Minikube
      shell: cmd
      run: |
        @echo off
        echo [INFO] Chargement de l'image Docker dans Minikube...
        
        REM Chercher minikube dans le PATH ou dans les emplacements usuels
        set MINIKUBE_CMD=
        where minikube >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          set MINIKUBE_CMD=minikube
        ) else (
          REM Essayer les chemins usuels sur Windows
          if exist "%USERPROFILE%\.minikube\bin\minikube.exe" (
            set MINIKUBE_CMD=%USERPROFILE%\.minikube\bin\minikube.exe
          ) else if exist "C:\minikube\minikube.exe" (
            set MINIKUBE_CMD=C:\minikube\minikube.exe
          )
        )
        
        if "%MINIKUBE_CMD%"=="" (
          echo [ATTENTION] Minikube non trouve dans le PATH
          echo [INFO] Utilisation de docker tag pour pointer vers minikube
          docker tag plant-disease-api:${{ github.sha }} plant-disease-api:latest
          echo [OK] Image taggee comme latest (minikube utilisera cette image avec imagePullPolicy: Never)
        ) else (
          echo [INFO] Utilisation de %MINIKUBE_CMD% pour charger l'image
          %MINIKUBE_CMD% image load plant-disease-api:${{ github.sha }} 2>nul || echo Image deja chargee
          %MINIKUBE_CMD% image load plant-disease-api:latest 2>nul || echo Image deja chargee
          echo [OK] Image chargee dans Minikube
        )
        
        REM S'assurer que l'image latest existe
        docker tag plant-disease-api:${{ github.sha }} plant-disease-api:latest
    
    - name: Deploy to Kubernetes
      shell: cmd
      run: |
        @echo off
        setlocal EnableExtensions
        if not defined GITHUB_WORKSPACE (
          echo [ERREUR] GITHUB_WORKSPACE non defini
          exit /b 1
        )
        cd /d "%GITHUB_WORKSPACE%" || exit /b 1
        if not exist k8s mkdir k8s
        set "DEPLOY_PS=%GITHUB_WORKSPACE%\k8s\deploy_tmp.ps1"

        >"%DEPLOY_PS%" echo $ErrorActionPreference = 'Stop'
        >>"%DEPLOY_PS%" echo Set-Location "%GITHUB_WORKSPACE%"
        >>"%DEPLOY_PS%" echo if (-not (Test-Path "data/class_mapping.yaml")) { Write-Error "data/class_mapping.yaml introuvable"; exit 1 }
        >>"%DEPLOY_PS%" echo if (-not (Test-Path "k8s")) { New-Item -ItemType Directory -Path "k8s" ^| Out-Null }
        >>"%DEPLOY_PS%" echo $cmFile = "k8s/class-mapping-config.generated.yaml"
        >>"%DEPLOY_PS%" echo $cmErr  = "k8s/class-mapping-config.generated.err.txt"
        >>"%DEPLOY_PS%" echo Write-Host "[INFO] Deploiement des manifests Kubernetes..."
        >>"%DEPLOY_PS%" echo kubectl apply -f k8s/namespace.yaml
        >>"%DEPLOY_PS%" echo Write-Host "[INFO] namespace apply done"
        >>"%DEPLOY_PS%" echo kubectl apply -f k8s/configmap.yaml
        >>"%DEPLOY_PS%" echo Write-Host "[INFO] api-config apply done"
        >>"%DEPLOY_PS%" echo Write-Host "[INFO] Creation du ConfigMap class-mapping-config depuis data/class_mapping.yaml"
        >>"%DEPLOY_PS%" echo Remove-Item $cmFile -ErrorAction SilentlyContinue
        >>"%DEPLOY_PS%" echo Remove-Item $cmErr  -ErrorAction SilentlyContinue
        >>"%DEPLOY_PS%" echo kubectl create configmap class-mapping-config --from-file=class_mapping.yaml=data/class_mapping.yaml -n plant-disease-mlops --dry-run=client -o yaml ^> $cmFile 2^> $cmErr
        >>"%DEPLOY_PS%" echo $size = (Get-Item $cmFile).Length
        >>"%DEPLOY_PS%" echo Write-Host "[INFO] CM_FILE size=$size bytes"
        >>"%DEPLOY_PS%" echo if ($size -eq 0) { Write-Error "YAML ConfigMap vide"; Get-Content $cmErr; exit 1 }
        >>"%DEPLOY_PS%" echo try { kubectl apply -f $cmFile 2^> $cmErr; Write-Host "[INFO] kubectl apply OK" } catch { Write-Error "[ERREUR] kubectl apply a echoue"; Get-Content $cmErr; Write-Host "[INFO] Debut du YAML genere:"; Get-Content $cmFile; exit 1 }
        >>"%DEPLOY_PS%" echo Remove-Item $cmFile,$cmErr -ErrorAction SilentlyContinue
        >>"%DEPLOY_PS%" echo Write-Host "[INFO] ConfigMap class-mapping-config OK, suite du deploiement..."
        >>"%DEPLOY_PS%" echo Write-Host "[INFO] Suppression des anciens pods plant-disease-api (si existants)..."
        >>"%DEPLOY_PS%" echo try { kubectl delete pod -l app=plant-disease-api -n plant-disease-mlops --ignore-not-found=true ^| Out-Null; Write-Host "[INFO] kubectl delete pod OK" } catch { Write-Host "[WARN] kubectl delete pod a retourne une erreur (ignoree)" }
        >>"%DEPLOY_PS%" echo kubectl apply -f k8s/api-deployment.yaml
        >>"%DEPLOY_PS%" echo Write-Host "[INFO] kubectl apply deployment OK"
        >>"%DEPLOY_PS%" echo kubectl apply -f k8s/api-service.yaml
        >>"%DEPLOY_PS%" echo Write-Host "[INFO] kubectl apply service OK"
        >>"%DEPLOY_PS%" echo Write-Host "[INFO] Mise a jour de l'image du deployment..."
        >>"%DEPLOY_PS%" echo try { kubectl set image deployment/plant-disease-api api=plant-disease-api:latest -n plant-disease-mlops ^| Out-Null; Write-Host "[INFO] kubectl set image OK" } catch { Write-Host "[WARN] kubectl set image a echoue ou Deployment non trouve, creation en cours..." }
        >>"%DEPLOY_PS%" echo Write-Host "[INFO] Attente du rollout..."
        >>"%DEPLOY_PS%" echo kubectl rollout status deployment/plant-disease-api -n plant-disease-mlops --timeout=300s
        >>"%DEPLOY_PS%" echo Write-Host "[OK] Deploiement termine"
        >>"%DEPLOY_PS%" echo Write-Host "[INFO] Status des pods:"
        >>"%DEPLOY_PS%" echo kubectl get pods -n plant-disease-mlops

        powershell -NoProfile -ExecutionPolicy Bypass -File "%DEPLOY_PS%"
        set "LASTERR=%ERRORLEVEL%"
        if exist "%DEPLOY_PS%" del /q "%DEPLOY_PS%"
        if %LASTERR% NEQ 0 exit /b %LASTERR%
        echo [INFO] Deploy step completed successfully
