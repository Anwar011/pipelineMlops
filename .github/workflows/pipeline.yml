name: MLOps Pipeline

on:
  push:
    branches:
      - main
    paths:
      - 'data/raw.dvc'
      - '.dvc/**'
      - 'data/raw/**'
  workflow_dispatch:  # Trigger manuel pour tests

jobs:
  train-and-deploy:
    runs-on: self-hosted  # Utiliser self-hosted runner
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Setup Python (if not available)
      shell: cmd
      run: |
        @echo off
        where python3 >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python3 --version
          goto :end
        )
        where python >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python --version
          goto :end
        )
        echo Python3 non trouvé, installation requise
        exit /b 1
        :end
    
    - name: Install dependencies
      shell: cmd
      run: |
        @echo off
        where python3 >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python3 -m pip install --upgrade pip --user
          python3 -m pip install -r requirements.txt --user
        ) else (
          python -m pip install --upgrade pip --user
          python -m pip install -r requirements.txt --user
        )
        set "PATH=%USERPROFILE%\.local\bin;%PATH%"
    
    - name: Install DVC (if not available)
      shell: cmd
      run: |
        @echo off
        where dvc >nul 2>&1
        if %ERRORLEVEL% NEQ 0 (
          where python3 >nul 2>&1
          if %ERRORLEVEL% EQU 0 (
            python3 -m pip install "dvc[s3]" --user
          ) else (
            python -m pip install "dvc[s3]" --user
          )
          set "PATH=%USERPROFILE%\.local\bin;%PATH%"
        )
    
    - name: Setup DVC
      shell: cmd
      run: |
        @echo off
        set "PATH=%USERPROFILE%\.local\bin;%PATH%"
        dvc remote modify storage --local url .dvc/storage 2>nul
        if %ERRORLEVEL% NEQ 0 (
          echo Remote config failed, continuons...
        )
        dvc pull 2>nul
        if %ERRORLEVEL% NEQ 0 (
          echo [INFO] Pas de donnees DVC disponibles dans le storage local
          echo [INFO] Tentative de copie automatique des donnees...
        )
        exit /b 0
    
    - name: Copy data if needed (self-hosted runner)
      shell: cmd
      run: |
        @echo off
        set "PATH=%USERPROFILE%\.local\bin;%PATH%"
        set "PYTHONPATH=."
        where python3 >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python3 scripts/copy_data_if_needed.py
        ) else (
          python scripts/copy_data_if_needed.py
        )
        if %ERRORLEVEL% NEQ 0 (
          echo [ATTENTION] Les donnees n'ont pas pu etre copiees automatiquement
          echo [INFO] Assurez-vous que les donnees sont disponibles dans data/raw/PlantVillage
        )
        exit /b 0
    
    - name: Check for data changes with DVC
      id: check_dvc
      shell: cmd
      env:
        GITHUB_EVENT_NAME: ${{ github.event_name }}
      run: |
        @echo off
        set "PATH=%USERPROFILE%\.local\bin;%PATH%"
        where python3 >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python3 scripts/check_dvc_changes.py
        ) else (
          python scripts/check_dvc_changes.py
        )
        exit /b 0
    
    # ============================================================================
    # ETAPES D'ENTRAINEMENT (COMMENTEES POUR TEST RAPIDE - UTILISE MODELE EXISTANT)
    # ============================================================================
    # - name: Prepare data
    #   if: steps.check_dvc.outputs.changed == 'true'
    #   shell: cmd
    #   run: |
    #     @echo off
    #     set "PYTHONPATH=."
    #     set "PATH=%USERPROFILE%\.local\bin;%PATH%"
    #     where python3 >nul 2>&1
    #     if %ERRORLEVEL% EQU 0 (
    #       python3 scripts/prepare_data.py
    #     ) else (
    #       python scripts/prepare_data.py
    #     )
    # 
    # - name: Verify MLflow is running
    #   if: steps.check_dvc.outputs.changed == 'true'
    #   shell: cmd
    #   run: |
    #     @echo off
    #     echo Vérification que MLflow est accessible...
    #     curl -f http://localhost:5000/health >nul 2>&1
    #     if %ERRORLEVEL% NEQ 0 (
    #       echo [ERREUR] MLflow n'est pas accessible sur http://localhost:5000
    #       echo Veuillez démarrer MLflow avec: cd docker ^&^& docker-compose up -d mlflow
    #       exit /b 1
    #     )
    #     echo [OK] MLflow est accessible
    # 
    # - name: Train model
    #   if: steps.check_dvc.outputs.changed == 'true'
    #   shell: cmd
    #   run: |
    #     @echo off
    #     set "PYTHONPATH=."
    #     set "PATH=%USERPROFILE%\.local\bin;%PATH%"
    #     where python3 >nul 2>&1
    #     if %ERRORLEVEL% EQU 0 (
    #       python3 src/training/train.py --config configs/config.yaml
    #     ) else (
    #       python src/training/train.py --config configs/config.yaml
    #     )
    # 
    # - name: Verify model in MLflow
    #   if: steps.check_dvc.outputs.changed == 'true'
    #   shell: cmd
    #   run: |
    #     @echo off
    #     set "PYTHONPATH=."
    #     set "PATH=%USERPROFILE%\.local\bin;%PATH%"
    #     where python3 >nul 2>&1
    #     if %ERRORLEVEL% EQU 0 (
    #       python3 scripts/verify_mlflow.py
    #     ) else (
    #       python scripts/verify_mlflow.py
    #     )
    
    - name: Verify MLflow is running
      shell: cmd
      run: |
        @echo off
        echo Vérification que MLflow est accessible...
        curl -f http://localhost:5000/health >nul 2>&1
        if %ERRORLEVEL% NEQ 0 (
          echo [ERREUR] MLflow n'est pas accessible sur http://localhost:5000
          echo Veuillez démarrer MLflow avec: cd docker ^&^& docker-compose up -d mlflow
          exit /b 1
        )
        echo [OK] MLflow est accessible
    
    - name: Get latest model from MLflow
      shell: cmd
      run: |
        @echo off
        echo [INFO] Recuperation du modele depuis MLflow (modele deja entraine)
        set "PYTHONPATH=."
        set "PATH=%USERPROFILE%\.local\bin;%PATH%"
        where python3 >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          python3 scripts/get_latest_model.py --tracking-uri http://localhost:5000 --experiment-name plant_disease_mvp --output-file models/best_model.pth
        ) else (
          python scripts/get_latest_model.py --tracking-uri http://localhost:5000 --experiment-name plant_disease_mvp --output-file models/best_model.pth
        )
    
    - name: Build Docker image
      shell: cmd
      run: |
        @echo off
        docker build -t plant-disease-api:${{ github.sha }} -f docker/Dockerfile .
        docker tag plant-disease-api:${{ github.sha }} plant-disease-api:latest
        echo [OK] Image Docker buildée: plant-disease-api:${{ github.sha }}
    
    - name: Load Docker image into Minikube
      shell: cmd
      run: |
        @echo off
        echo [INFO] Chargement de l'image Docker dans Minikube...
        
        REM Chercher minikube dans le PATH ou dans les emplacements usuels
        set MINIKUBE_CMD=
        where minikube >nul 2>&1
        if %ERRORLEVEL% EQU 0 (
          set MINIKUBE_CMD=minikube
        ) else (
          REM Essayer les chemins usuels sur Windows
          if exist "%USERPROFILE%\.minikube\bin\minikube.exe" (
            set MINIKUBE_CMD=%USERPROFILE%\.minikube\bin\minikube.exe
          ) else if exist "C:\minikube\minikube.exe" (
            set MINIKUBE_CMD=C:\minikube\minikube.exe
          )
        )
        
        if "%MINIKUBE_CMD%"=="" (
          echo [ATTENTION] Minikube non trouve dans le PATH
          echo [INFO] Utilisation de docker tag pour pointer vers minikube
          docker tag plant-disease-api:${{ github.sha }} plant-disease-api:latest
          echo [OK] Image taggee comme latest (minikube utilisera cette image avec imagePullPolicy: Never)
        ) else (
          echo [INFO] Utilisation de %MINIKUBE_CMD% pour charger l'image
          %MINIKUBE_CMD% image load plant-disease-api:${{ github.sha }} 2>nul || echo Image deja chargee
          %MINIKUBE_CMD% image load plant-disease-api:latest 2>nul || echo Image deja chargee
          echo [OK] Image chargee dans Minikube
        )
        
        REM S'assurer que l'image latest existe
        docker tag plant-disease-api:${{ github.sha }} plant-disease-api:latest
    
    - name: Deploy to Kubernetes
      shell: cmd
      run: |
        @echo off
        setlocal EnableExtensions
        REM Toujours se placer dans le workspace (evite les soucis de chemins/redirect)
        if not defined GITHUB_WORKSPACE (
          echo [ERREUR] GITHUB_WORKSPACE n'est pas defini
          exit /b 1
        )
        cd /d "%GITHUB_WORKSPACE%"
        if errorlevel 1 (
          echo [ERREUR] Impossible de cd dans %GITHUB_WORKSPACE%
          exit /b 1
        )
        where kubectl >nul 2>&1
        if errorlevel 1 (
          echo [ERREUR] kubectl n'est pas installé
          exit /b 1
        )

        REM Fichiers temporaires pour le ConfigMap (definis AVANT le bloc IF pour eviter les soucis d'expansion cmd)
        REM On ecrit dans le workspace (plus fiable que %TEMP% sur certains runners)
        if not exist "k8s" mkdir "k8s"
        set "CM_FILE=k8s\class-mapping-config.generated.yaml"
        set "CM_ERR=k8s\class-mapping-config.generated.err.txt"
        
        echo [INFO] Deploiement des manifests Kubernetes...
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/configmap.yaml

        REM (Optionnel) PVC non montee dans l'API en mode actuel, donc on ne l'applique pas ici
        REM kubectl apply -f k8s/pvc.yaml

        REM Creer/mettre a jour le ConfigMap class-mapping-config depuis le vrai fichier
        if exist "data\class_mapping.yaml" (
          echo [INFO] Creation du ConfigMap class-mapping-config depuis data\class_mapping.yaml
          echo [INFO] CM_FILE=%CM_FILE%
          echo [INFO] CWD=%CD%
          if not exist "k8s" (
            echo [INFO] Dossier k8s manquant, creation...
            mkdir "k8s"
          )
          dir "k8s" >nul 2>nul
          REM Sur Windows runners, le pipe peut retourner un code != 0. On passe par un fichier temporaire.
          if exist "%CM_ERR%" del /q "%CM_ERR%" >nul 2>nul
          if exist "%CM_FILE%" del /q "%CM_FILE%" >nul 2>nul

          kubectl create configmap class-mapping-config --from-file=class_mapping.yaml=data/class_mapping.yaml -n plant-disease-mlops --dry-run=client -o yaml > "%CM_FILE%" 2> "%CM_ERR%"
          echo [INFO] kubectl create done
          if errorlevel 1 (
            echo [ERREUR] kubectl create configmap a echoue. Stderr:
            type "%CM_ERR%" 2>nul
            exit /b 1
          )

          if not exist "%CM_FILE%" (
            echo [ERREUR] Fichier YAML non cree: %CM_FILE%
            type "%CM_ERR%" 2>nul
            exit /b 1
          )
 
          for %%A in ("%CM_FILE%") do (
            echo [INFO] CM_FILE size=%%~zA bytes
            if %%~zA==0 (
              echo [ERREUR] YAML ConfigMap vide: %CM_FILE%
              type "%CM_ERR%" 2>nul
              exit /b 1
            )
          )

          kubectl apply -f "%CM_FILE%" 2> "%CM_ERR%"
          echo [INFO] kubectl apply done
          if errorlevel 1 (
            echo [ERREUR] kubectl apply a echoue. Stderr:
            type "%CM_ERR%" 2>nul
            echo [INFO] Debut du YAML genere:
            more +1 "%CM_FILE%"
            exit /b 1
          )

          REM Nettoyer les fichiers generes (ne jamais faire echouer le step)
          if exist "%CM_ERR%" del /q "%CM_ERR%" >nul 2>nul
          if exist "%CM_FILE%" del /q "%CM_FILE%" >nul 2>nul
        ) else (
          echo [ERREUR] data\class_mapping.yaml introuvable (necessaire pour class-mapping-config)
          exit /b 1
        )

        echo [INFO] ConfigMap class-mapping-config OK, suite du deploiement...

        REM Nettoyer les anciens pods (ImagePullBackOff, etc.)
        echo [INFO] Suppression des anciens pods plant-disease-api (si existants)...
        kubectl delete pod -l app=plant-disease-api -n plant-disease-mlops --ignore-not-found=true
        if errorlevel 1 (
          echo [ERREUR] kubectl delete pod a echoue
          exit /b 1
        )
        echo [INFO] kubectl delete pod OK

        kubectl apply -f k8s/api-deployment.yaml
        if errorlevel 1 (
          echo [ERREUR] kubectl apply deployment a echoue
          kubectl describe deployment/plant-disease-api -n plant-disease-mlops
          exit /b 1
        )
        echo [INFO] kubectl apply deployment OK

        kubectl apply -f k8s/api-service.yaml
        if errorlevel 1 (
          echo [ERREUR] kubectl apply service a echoue
          kubectl describe service/api-service -n plant-disease-mlops
          exit /b 1
        )
        echo [INFO] kubectl apply service OK
        
        echo [INFO] Mise a jour de l'image du deployment...
        kubectl set image deployment/plant-disease-api api=plant-disease-api:latest -n plant-disease-mlops || echo Deployment non trouvé, création en cours...
        if errorlevel 1 (
          echo [ERREUR] kubectl set image a echoue
          exit /b 1
        )
        echo [INFO] kubectl set image OK
        
        echo [INFO] Attente du rollout...
        kubectl rollout status deployment/plant-disease-api -n plant-disease-mlops --timeout=300s
        if errorlevel 1 (
          echo [ERREUR] Rollout failed / timeout. Diagnostic:
          kubectl get pods -n plant-disease-mlops
          kubectl describe deployment/plant-disease-api -n plant-disease-mlops
          echo [INFO] Logs (last 200 lines):
          kubectl logs deployment/plant-disease-api -n plant-disease-mlops --tail=200 --all-containers=true
          exit /b 1
        )
        
        echo [OK] Déploiement terminé
        echo [INFO] Status des pods:
        kubectl get pods -n plant-disease-mlops
        exit /b 0
